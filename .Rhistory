version
which rstudio
print("RStudio is ready!")
the.data <- as.matrix(read.table("ENB.txt"))
load("~/Downloads/ENB 2024T3 2/AggWaFit718.R")
file.exists("ENB.txt")
the.data <- as.matrix(read.table(file.choose()))
# 读取数据并将其转化为矩阵
the.data <- as.matrix(read.table("ENB.txt", header=TRUE, sep=","))
getwd()
the.data <- as.matrix(read.table("~/Desktop/ENB.txt", header=TRUE, sep=","))
# 确定数据的行数和列数
num_samples <- nrow(the.data)
num_col <- ncol(the.data)
# 随机选择450行数据
set.seed(224270349)  # 使用你的学生ID作为种子，确保结果可复现
my.data <- the.data[sample(1:num_samples, 450), ]
# X1 和 Y 的散点图
plot(my.data[,1], my.data[,6], main="X1 vs Y", xlab="X1", ylab="Y")
the.data <- as.matrix(read.table("ENB.txt"))
setwd("path_to_your_desktop_folder")
source("AggWaFit718.R")
getwd()  # 查看当前工作目录
setwd("/Users/fengxueying/Desktop")
source("AggWaFit718.R")
WAM_fit <- fit.QAM(transformed_matrix)  # 假设 'transformed_matrix' 是您的数据矩阵
# 设置工作目录为文件所在位置，确保 ENB.txt 可被读取
setwd("/Users/fengxueying/Desktop")  # 如果你的文件在桌面，调整路径为实际路径
# 读取 ENB.txt 文件
data <- read.table("ENB.txt", header = TRUE, sep = "\t")  # 如果是制表符分隔
# 如果是空格分隔，可以使用 sep = " " 替代 \t
# 查看数据
head(data)
# 查看数据结构
str(data)
# 查看数据摘要
summary(data)
# 读取数据，假设是以空格分隔的
data <- read.table("ENB.txt", header = FALSE, sep = " ", stringsAsFactors = FALSE)
# 查看数据的前几行
head(data)
# 加载并清理数据
enb_data <- read.table("ENB.txt", header = FALSE)
# 设置列名
colnames(enb_data) <- c("Index", "Temperature1", "WindSpeed1", "Temperature2", "WindSpeed2", "Temperature3", "Category")
# 查看数据结构
head(enb_data)
source("AggWaFit718.R")
WAM_fit <- fit.QAM(enb_data, type = "WAM")
# 加载数据
enb_data <- read.table("ENB.txt", header = TRUE)
# 转换为矩阵格式
enb_data_matrix <- as.matrix(enb_data)
WAM_fit <- fit.QAM(enb_data_matrix, type = "WAM")
# 假设 enb_data_matrix 是你已经加载并准备好的数据矩阵
# 计算每个变量的加权算术平均（WAM）
weights <- rep(1 / ncol(enb_data_matrix), ncol(enb_data_matrix))  # 假设所有变量的权重相等
WAM_result <- colSums(enb_data_matrix * weights)  # 加权求和
WAM_result  # 输出 WAM 结果
# 标准化数据
enb_data_scaled <- scale(enb_data_matrix)
# 计算每个变量的加权算术平均（WAM）
WAM_result <- colSums(enb_data_scaled * weights)  # 加权求和
WAM_result  # 输出 WAM 结果
source("AggWaFit718.R")
# 假设你已经加载了 enb_data_matrix
# 假设所有变量的权重相等
weights <- rep(1 / ncol(enb_data_matrix), ncol(enb_data_matrix))
# 1. 计算加权算术平均 (WAM)
WAM_result <- colSums(enb_data_matrix * weights)
print(WAM_result)
# 2. 计算加权幂均值 (WPM) - p = 0.5
WPM_result_05 <- apply(enb_data_matrix, 2, function(x) sum(weights * (x ^ 0.5)))
print(WPM_result_05)
# 3. 计算加权幂均值 (WPM) - p = 2
WPM_result_2 <- apply(enb_data_matrix, 2, function(x) sum(weights * (x ^ 2)))
print(WPM_result_2)
# 4. 计算有序加权平均 (OWA)
OWA_result <- apply_OWA(enb_data_matrix, weights)
# 假设你已经加载了 enb_data_matrix
weights <- rep(1 / ncol(enb_data_matrix), ncol(enb_data_matrix))
# 1. 计算加权算术平均 (WAM)
WAM_result <- colSums(enb_data_matrix * weights)
print(WAM_result)
# 2. 计算加权幂均值 (WPM) - p = 0.5
WPM_result_05 <- apply(enb_data_matrix, 2, function(x) sum(sweep(x, 2, weights, `*`) ^ 0.5))
# 假设你已经加载了 enb_data_matrix
weights <- rep(1 / ncol(enb_data_matrix), ncol(enb_data_matrix))
# 1. 计算加权算术平均 (WAM)
WAM_result <- colSums(enb_data_matrix * weights)
print(WAM_result)
# 2. 计算加权幂均值 (WPM) - p = 0.5
WPM_result_05 <- apply(enb_data_matrix, 2, function(x) sum(sweep(x, 2, weights, `*`) ^ 0.5))
# 1. 计算加权算术平均 (WAM)
WAM_result <- colSums(enb_data_matrix * weights)
print(WAM_result)
# 2. 计算加权幂均值 (WPM) - p = 0.5
# 使用 sweep 和 apply 逐列应用
WPM_result_05 <- apply(enb_data_matrix, 2, function(x) sum(x * weights ^ 0.5))
print(WPM_result_05)
# 3. 计算加权幂均值 (WPM) - p = 2
WPM_result_2 <- apply(enb_data_matrix, 2, function(x) sum(x * weights ^ 2))
print(WPM_result_2)
# 假设 enb_data_matrix 已经加载并准备好
# 确保权重向量与数据矩阵的列数一致
weights <- rep(1 / ncol(enb_data_matrix), ncol(enb_data_matrix))
# 1. 计算加权算术平均 (WAM)
WAM_result <- colSums(enb_data_matrix * weights)
print("加权算术平均 (WAM):")
print(WAM_result)
# 2. 计算加权幂均值 (WPM) - p = 0.5
WPM_result_05 <- apply(enb_data_matrix, 2, function(x) sum(weights * (x ^ 0.5)))
print("加权幂均值 (WPM) - p = 0.5:")
print(WPM_result_05)
# 3. 计算加权幂均值 (WPM) - p = 2
WPM_result_2 <- apply(enb_data_matrix, 2, function(x) sum(weights * (x ^ 2)))
print("加权幂均值 (WPM) - p = 2:")
print(WPM_result_2)
# 4. 计算有序加权平均 (OWA)
# 确保我们有一个适当的有序加权平均 (OWA) 函数
apply_OWA <- function(x, weights) {
ordered_x <- sort(x, decreasing = TRUE)  # 从大到小排序
sum(ordered_x * weights)  # 加权求和
}
# 应用 OWA 计算
OWA_result <- apply(enb_data_matrix, 2, function(x) apply_OWA(x, weights))
print("有序加权平均 (OWA):")
print(OWA_result)
# 假设你已经加载并处理了数据
# 1. 数据预处理（标准化）
enb_data_scaled <- scale(enb_data_matrix)  # 标准化数据，确保每个变量处于相同的尺度
# 假设权重是已经计算的
weights <- rep(1 / ncol(enb_data_matrix), ncol(enb_data_matrix))  # 假设权重是均等的
# 2. 计算加权算术平均 (WAM)
WAM_result <- colSums(enb_data_scaled * weights)
# 打印结果
print("加权算术平均 (WAM):")
print(WAM_result)
# 3. 计算加权幂均值 (WPM) - p = 0.5 和 p = 2
# WPM for p = 0.5
WPM_result_05 <- apply(enb_data_scaled, 2, function(x) sum(weights * (x ^ 0.5)))
print("加权幂均值 (WPM) - p = 0.5:")
print(WPM_result_05)
# WPM for p = 2
WPM_result_2 <- apply(enb_data_scaled, 2, function(x) sum(weights * (x ^ 2)))
print("加权幂均值 (WPM) - p = 2:")
print(WPM_result_2)
# 4. 计算有序加权平均 (OWA)
# 定义 OWA 函数
apply_OWA <- function(data, weights) {
sorted_data <- apply(data, 2, sort)  # 对每列数据进行排序
owa_result <- apply(sorted_data, 2, function(x) sum(x * weights))  # 计算加权和
return(owa_result)
}
# 计算 OWA
OWA_result <- apply_OWA(enb_data_scaled, weights)
print("有序加权平均 (OWA):")
print(OWA_result)
# 5. 保存结果
# 将结果保存为数据框（表格）
WAM_table <- data.frame(WAM_result)
WPM_table_05 <- data.frame(WPM_result_05)
WPM_table_2 <- data.frame(WPM_result_2)
OWA_table <- data.frame(OWA_result)
# 保存为 CSV 文件，用于任务 5
write.csv(WAM_table, "WAM_table.csv", row.names = FALSE)
write.csv(WPM_table_05, "WPM_table_05.csv", row.names = FALSE)
write.csv(WPM_table_2, "WPM_table_2.csv", row.names = FALSE)
write.csv(OWA_table, "OWA_table.csv", row.names = FALSE)
# 打印完成提示
print("所有结果已成功保存为 CSV 文件")
